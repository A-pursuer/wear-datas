# 可视化技术点详解

## 1. Plotly交互式图表设计

### 1.1 图表类型选择策略

```python
import plotly.graph_objects as go
import plotly.express as px
from plotly.subplots import make_subplots
import numpy as np

class ChartTypeManager:
    """图表类型管理器 - 根据数据特性选择最佳可视化方式"""

    @staticmethod
    def get_optimal_chart_type(data_characteristics):
        """
        根据数据特征推荐最佳图表类型

        Args:
            data_characteristics: dict containing:
                - data_size: 数据量大小
                - frequency_content: 是否包含频域信息
                - multi_channel: 是否多通道
                - time_series: 是否时间序列
                - comparison_mode: 是否对比模式

        Returns:
            str: 推荐的图表类型
        """
        if data_characteristics.get('frequency_content'):
            if data_characteristics.get('comparison_mode'):
                return 'frequency_comparison'
            else:
                return 'frequency_spectrum'

        elif data_characteristics.get('data_size', 0) > 100000:
            return 'decimated_time_series'

        elif data_characteristics.get('multi_channel'):
            return 'multi_subplot'

        elif data_characteristics.get('comparison_mode'):
            return 'overlay_comparison'

        else:
            return 'standard_time_series'
```

### 1.2 时域信号可视化

```python
class TimeDomainVisualizer:
    """时域信号可视化器"""

    def __init__(self, theme_config=None):
        self.theme = theme_config or self._default_theme()

    def create_time_series_chart(self, datasets, downsample_factor=1):
        """
        创建时域波形图

        Args:
            datasets: list of dict containing:
                - data: 时域数据
                - time: 时间轴
                - label: 数据标签
                - color: 线条颜色
            downsample_factor: 降采样因子

        Returns:
            plotly.graph_objects.Figure: 时域图表
        """
        fig = go.Figure()

        for dataset in datasets:
            time = dataset['time'][::downsample_factor]
            data = dataset['data'][::downsample_factor]

            # 添加时域波形
            fig.add_trace(go.Scatter(
                x=time,
                y=data,
                mode='lines',
                name=dataset['label'],
                line=dict(
                    color=dataset.get('color', '#1f77b4'),
                    width=1.5
                ),
                hovertemplate=(
                    f"<b>{dataset['label']}</b><br>"
                    "时间: %{x:.4f}s<br>"
                    "幅值: %{y:.6f}<br>"
                    "<extra></extra>"
                )
            ))

        # 布局配置
        fig.update_layout(
            title={
                'text': '时域波形对比分析',
                'x': 0.5,
                'font': {'size': 16, 'color': self.theme['title_color']}
            },
            xaxis=dict(
                title='时间 (s)',
                showgrid=True,
                gridcolor=self.theme['grid_color'],
                zeroline=False
            ),
            yaxis=dict(
                title='加速度 (m/s²)',
                showgrid=True,
                gridcolor=self.theme['grid_color'],
                zeroline=True,
                zerolinecolor=self.theme['zero_line_color']
            ),
            legend=dict(
                orientation="h",
                yanchor="bottom",
                y=1.02,
                xanchor="right",
                x=1
            ),
            hovermode='x unified',
            template='plotly_white',
            height=500
        )

        # 添加缩放工具
        fig.update_layout(
            xaxis=dict(
                rangeslider=dict(visible=True, thickness=0.1),
                type='linear'
            )
        )

        return fig

    def create_statistical_overview(self, datasets):
        """
        创建统计特征概览图

        Args:
            datasets: 数据集列表

        Returns:
            plotly.graph_objects.Figure: 统计特征图
        """
        # 计算统计特征
        stats_data = []
        for dataset in datasets:
            stats = self._compute_statistics(dataset['data'])
            stats['label'] = dataset['label']
            stats_data.append(stats)

        # 创建子图
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=[
                'RMS值对比', '峰值对比',
                '偏度对比', '峭度对比'
            ],
            specs=[[{'type': 'bar'}, {'type': 'bar'}],
                   [{'type': 'bar'}, {'type': 'bar'}]]
        )

        labels = [data['label'] for data in stats_data]

        # RMS对比
        fig.add_trace(go.Bar(
            x=labels,
            y=[data['rms'] for data in stats_data],
            name='RMS',
            marker_color='lightblue'
        ), row=1, col=1)

        # 峰值对比
        fig.add_trace(go.Bar(
            x=labels,
            y=[data['peak'] for data in stats_data],
            name='Peak',
            marker_color='lightcoral'
        ), row=1, col=2)

        # 偏度对比
        fig.add_trace(go.Bar(
            x=labels,
            y=[data['skewness'] for data in stats_data],
            name='Skewness',
            marker_color='lightgreen'
        ), row=2, col=1)

        # 峭度对比
        fig.add_trace(go.Bar(
            x=labels,
            y=[data['kurtosis'] for data in stats_data],
            name='Kurtosis',
            marker_color='lightyellow'
        ), row=2, col=2)

        fig.update_layout(
            title_text="统计特征对比分析",
            showlegend=False,
            height=600
        )

        return fig

    def _compute_statistics(self, data):
        """计算信号统计特征"""
        from scipy import stats

        return {
            'rms': np.sqrt(np.mean(data**2)),
            'peak': np.max(np.abs(data)),
            'skewness': stats.skew(data),
            'kurtosis': stats.kurtosis(data)
        }

    def _default_theme(self):
        """默认主题配置"""
        return {
            'title_color': '#2c3e50',
            'grid_color': '#ecf0f1',
            'zero_line_color': '#bdc3c7',
            'background_color': '#ffffff'
        }
```

### 1.3 频域可视化

```python
class FrequencyDomainVisualizer:
    """频域可视化器"""

    def create_spectrum_chart(self, datasets, log_scale=False):
        """
        创建频谱分析图

        Args:
            datasets: list of dict containing:
                - frequencies: 频率数组
                - magnitude: 幅值谱
                - phase: 相位谱（可选）
                - label: 标签

        Returns:
            plotly.graph_objects.Figure: 频谱图
        """
        fig = make_subplots(
            rows=2, cols=1,
            subplot_titles=['幅值谱', '相位谱'],
            vertical_spacing=0.12,
            shared_xaxes=True
        )

        for dataset in datasets:
            freqs = dataset['frequencies']
            magnitude = dataset['magnitude']

            # 幅值谱
            fig.add_trace(go.Scatter(
                x=freqs,
                y=magnitude,
                mode='lines',
                name=f"{dataset['label']} - 幅值",
                line=dict(width=1.5),
                hovertemplate=(
                    f"<b>{dataset['label']}</b><br>"
                    "频率: %{x:.2f} Hz<br>"
                    "幅值: %{y:.4f}<br>"
                    "<extra></extra>"
                )
            ), row=1, col=1)

            # 相位谱（如果提供）
            if 'phase' in dataset:
                fig.add_trace(go.Scatter(
                    x=freqs,
                    y=dataset['phase'],
                    mode='lines',
                    name=f"{dataset['label']} - 相位",
                    line=dict(width=1.5, dash='dot'),
                    showlegend=False
                ), row=2, col=1)

        # 布局配置
        fig.update_xaxes(title_text="频率 (Hz)", row=2, col=1)
        fig.update_yaxes(title_text="幅值", row=1, col=1)
        fig.update_yaxes(title_text="相位 (rad)", row=2, col=1)

        if log_scale:
            fig.update_yaxes(type="log", row=1, col=1)

        fig.update_layout(
            title_text="频域分析",
            height=700,
            hovermode='x unified'
        )

        return fig

    def create_spectrogram(self, time, frequencies, spectrogram_data, title="时频谱图"):
        """
        创建时频谱图（语谱图）

        Args:
            time: 时间轴
            frequencies: 频率轴
            spectrogram_data: 时频数据矩阵
            title: 图表标题

        Returns:
            plotly.graph_objects.Figure: 时频谱图
        """
        fig = go.Figure(data=go.Heatmap(
            x=time,
            y=frequencies,
            z=20 * np.log10(spectrogram_data + 1e-12),  # 转换为dB
            colorscale='Viridis',
            colorbar=dict(title="功率谱密度 (dB)")
        ))

        fig.update_layout(
            title=title,
            xaxis_title="时间 (s)",
            yaxis_title="频率 (Hz)",
            height=500
        )

        return fig

    def create_gear_frequency_analysis(self, freqs, spectrum, gear_frequencies):
        """
        创建齿轮特征频率分析图

        Args:
            freqs: 频率数组
            spectrum: 频谱数据
            gear_frequencies: dict containing gear characteristic frequencies

        Returns:
            plotly.graph_objects.Figure: 齿轮频率分析图
        """
        fig = go.Figure()

        # 添加频谱曲线
        fig.add_trace(go.Scatter(
            x=freqs,
            y=spectrum,
            mode='lines',
            name='频谱',
            line=dict(color='blue', width=1)
        ))

        # 标记齿轮特征频率
        colors = ['red', 'green', 'orange', 'purple']
        freq_types = ['啮合频率', '主动轮频率', '从动轮频率']

        for i, (freq_type, freq_value) in enumerate(gear_frequencies.items()):
            if freq_value <= np.max(freqs):
                # 找到最近的频率点
                freq_idx = np.argmin(np.abs(freqs - freq_value))

                fig.add_vline(
                    x=freq_value,
                    line=dict(color=colors[i % len(colors)], width=2, dash="dash"),
                    annotation_text=f"{freq_type}: {freq_value:.1f}Hz"
                )

        fig.update_layout(
            title="齿轮特征频率分析",
            xaxis_title="频率 (Hz)",
            yaxis_title="幅值",
            height=500,
            showlegend=True
        )

        return fig
```

### 1.4 对比分析可视化

```python
class ComparisonVisualizer:
    """对比分析可视化器"""

    def create_multi_condition_comparison(self, datasets):
        """
        创建多工况对比分析图

        Args:
            datasets: list of dict containing dataset information

        Returns:
            plotly.graph_objects.Figure: 多工况对比图
        """
        fig = make_subplots(
            rows=2, cols=2,
            subplot_titles=[
                '时域波形对比',
                '频谱对比',
                '统计特征雷达图',
                'RMS值变化趋势'
            ],
            specs=[
                [{'type': 'xy'}, {'type': 'xy'}],
                [{'type': 'scatterpolar'}, {'type': 'xy'}]
            ]
        )

        # 1. 时域波形对比
        for dataset in datasets:
            fig.add_trace(go.Scatter(
                x=dataset['time'],
                y=dataset['data'],
                mode='lines',
                name=dataset['label'],
                line=dict(width=1.5)
            ), row=1, col=1)

        # 2. 频谱对比
        for dataset in datasets:
            if 'frequencies' in dataset and 'spectrum' in dataset:
                fig.add_trace(go.Scatter(
                    x=dataset['frequencies'],
                    y=dataset['spectrum'],
                    mode='lines',
                    name=dataset['label'],
                    showlegend=False
                ), row=1, col=2)

        # 3. 统计特征雷达图
        self._add_radar_chart(fig, datasets, row=2, col=1)

        # 4. RMS趋势
        rms_values = [np.sqrt(np.mean(d['data']**2)) for d in datasets]
        labels = [d['label'] for d in datasets]

        fig.add_trace(go.Scatter(
            x=list(range(len(labels))),
            y=rms_values,
            mode='lines+markers',
            name='RMS趋势',
            line=dict(width=3),
            marker=dict(size=8),
            showlegend=False
        ), row=2, col=2)

        fig.update_xaxes(title_text="时间 (s)", row=1, col=1)
        fig.update_xaxes(title_text="频率 (Hz)", row=1, col=2)
        fig.update_xaxes(title_text="工况", tickvals=list(range(len(labels))), ticktext=labels, row=2, col=2)
        fig.update_yaxes(title_text="加速度", row=1, col=1)
        fig.update_yaxes(title_text="幅值", row=1, col=2)
        fig.update_yaxes(title_text="RMS值", row=2, col=2)

        fig.update_layout(
            title_text="多工况综合对比分析",
            height=800,
            showlegend=True
        )

        return fig

    def _add_radar_chart(self, fig, datasets, row, col):
        """添加雷达图到子图"""
        # 统计特征类型
        feature_names = ['RMS', 'Peak', 'Std', 'Skewness', 'Kurtosis']

        for dataset in datasets:
            data = dataset['data']

            # 计算特征值
            features = [
                np.sqrt(np.mean(data**2)),  # RMS
                np.max(np.abs(data)),       # Peak
                np.std(data),               # Std
                stats.skew(data),           # Skewness
                stats.kurtosis(data)        # Kurtosis
            ]

            # 归一化到0-1范围
            features_normalized = self._normalize_features(features)

            fig.add_trace(go.Scatterpolar(
                r=features_normalized + [features_normalized[0]],  # 闭合多边形
                theta=feature_names + [feature_names[0]],
                fill='toself',
                name=dataset['label'],
                opacity=0.6
            ), row=row, col=col)

    def _normalize_features(self, features):
        """归一化特征值到0-1范围"""
        # 简单的min-max归一化
        features = np.array(features)
        min_val = np.min(features)
        max_val = np.max(features)

        if max_val == min_val:
            return [0.5] * len(features)

        return ((features - min_val) / (max_val - min_val)).tolist()

    def create_wear_progression_analysis(self, wear_states_data):
        """
        创建磨损程度发展分析图

        Args:
            wear_states_data: dict with wear states as keys and data as values

        Returns:
            plotly.graph_objects.Figure: 磨损发展分析图
        """
        wear_order = ['正常', '轻磨', '重磨']

        fig = make_subplots(
            rows=1, cols=3,
            subplot_titles=['RMS变化', '峰值变化', '峭度变化'],
            shared_yaxes=False
        )

        # 计算各磨损状态的特征
        rms_values = []
        peak_values = []
        kurtosis_values = []

        for wear_state in wear_order:
            if wear_state in wear_states_data:
                data = wear_states_data[wear_state]['data']
                rms_values.append(np.sqrt(np.mean(data**2)))
                peak_values.append(np.max(np.abs(data)))
                kurtosis_values.append(stats.kurtosis(data))

        # RMS变化趋势
        fig.add_trace(go.Scatter(
            x=wear_order,
            y=rms_values,
            mode='lines+markers',
            name='RMS',
            line=dict(width=3, color='blue'),
            marker=dict(size=10)
        ), row=1, col=1)

        # 峰值变化趋势
        fig.add_trace(go.Scatter(
            x=wear_order,
            y=peak_values,
            mode='lines+markers',
            name='Peak',
            line=dict(width=3, color='red'),
            marker=dict(size=10),
            showlegend=False
        ), row=1, col=2)

        # 峭度变化趋势
        fig.add_trace(go.Scatter(
            x=wear_order,
            y=kurtosis_values,
            mode='lines+markers',
            name='Kurtosis',
            line=dict(width=3, color='green'),
            marker=dict(size=10),
            showlegend=False
        ), row=1, col=3)

        fig.update_yaxes(title_text="RMS值", row=1, col=1)
        fig.update_yaxes(title_text="峰值", row=1, col=2)
        fig.update_yaxes(title_text="峭度", row=1, col=3)

        fig.update_layout(
            title_text="磨损程度发展趋势分析",
            height=400,
            showlegend=True
        )

        return fig
```

## 2. 性能优化技术

### 2.1 大数据量可视化优化

```python
class PerformanceOptimizer:
    """可视化性能优化器"""

    @staticmethod
    def intelligent_downsampling(data, target_points=5000, method='lttb'):
        """
        智能降采样算法

        Args:
            data: 输入数据 (time, values)
            target_points: 目标点数
            method: 降采样方法 ('lttb', 'max_min', 'uniform')

        Returns:
            tuple: (下采样的时间, 下采样的数值)
        """
        if len(data[0]) <= target_points:
            return data

        if method == 'lttb':
            return PerformanceOptimizer._lttb_downsample(data, target_points)
        elif method == 'max_min':
            return PerformanceOptimizer._max_min_downsample(data, target_points)
        elif method == 'uniform':
            step = len(data[0]) // target_points
            return data[0][::step], data[1][::step]

    @staticmethod
    def _lttb_downsample(data, target_points):
        """
        LTTB (Largest Triangle Three Buckets) 降采样算法
        保持数据的视觉特征
        """
        time, values = data
        n = len(time)

        if n <= target_points:
            return time, values

        # 计算每个bucket的大小
        bucket_size = (n - 2) / (target_points - 2)

        # 初始化结果
        sampled_time = [time[0]]
        sampled_values = [values[0]]

        # LTTB算法实现
        prev_point = (time[0], values[0])

        for i in range(1, target_points - 1):
            # 当前bucket范围
            start_idx = int(i * bucket_size) + 1
            end_idx = int((i + 1) * bucket_size) + 1
            end_idx = min(end_idx, n - 1)

            # 下一个bucket的平均点
            next_start = int((i + 1) * bucket_size) + 1
            next_end = int((i + 2) * bucket_size) + 1
            next_end = min(next_end, n)

            if next_start < n:
                next_avg_time = np.mean(time[next_start:next_end])
                next_avg_value = np.mean(values[next_start:next_end])
            else:
                next_avg_time = time[-1]
                next_avg_value = values[-1]

            # 在当前bucket中找到形成最大三角形的点
            max_area = 0
            max_idx = start_idx

            for j in range(start_idx, end_idx):
                area = abs((prev_point[0] - next_avg_time) * (values[j] - prev_point[1]) -
                          (prev_point[0] - time[j]) * (next_avg_value - prev_point[1]))

                if area > max_area:
                    max_area = area
                    max_idx = j

            sampled_time.append(time[max_idx])
            sampled_values.append(values[max_idx])
            prev_point = (time[max_idx], values[max_idx])

        # 添加最后一个点
        sampled_time.append(time[-1])
        sampled_values.append(values[-1])

        return np.array(sampled_time), np.array(sampled_values)

    @staticmethod
    def _max_min_downsample(data, target_points):
        """
        最大最小值降采样 - 保持峰值信息
        """
        time, values = data
        n = len(time)
        bucket_size = n // target_points

        sampled_time = []
        sampled_values = []

        for i in range(0, n, bucket_size):
            bucket_end = min(i + bucket_size, n)
            bucket_values = values[i:bucket_end]
            bucket_time = time[i:bucket_end]

            # 找最大值和最小值
            max_idx = i + np.argmax(bucket_values)
            min_idx = i + np.argmin(bucket_values)

            # 按时间顺序添加
            if time[min_idx] < time[max_idx]:
                sampled_time.extend([time[min_idx], time[max_idx]])
                sampled_values.extend([values[min_idx], values[max_idx]])
            else:
                sampled_time.extend([time[max_idx], time[min_idx]])
                sampled_values.extend([values[max_idx], values[min_idx]])

        return np.array(sampled_time), np.array(sampled_values)
```

### 2.2 动态图表更新

```python
class DynamicChartManager:
    """动态图表管理器"""

    def __init__(self):
        self.update_queue = []
        self.last_update_time = 0
        self.update_interval = 0.1  # 100ms更新间隔

    def add_update_request(self, chart_id, update_data):
        """添加图表更新请求"""
        self.update_queue.append({
            'chart_id': chart_id,
            'data': update_data,
            'timestamp': time.time()
        })

    def create_incremental_update(self, fig, new_data, trace_index=0):
        """
        创建增量更新

        Args:
            fig: plotly图表对象
            new_data: 新数据
            trace_index: 要更新的trace索引

        Returns:
            dict: 增量更新配置
        """
        # 只更新数据，不重绘整个图表
        update_config = {
            'data': [
                {
                    'x': [new_data['x']],
                    'y': [new_data['y']]
                }
            ],
            'traces': [trace_index]
        }

        return update_config

    def batch_update_charts(self, updates):
        """批量更新图表"""
        # 合并相同图表的更新请求
        merged_updates = {}

        for update in updates:
            chart_id = update['chart_id']
            if chart_id not in merged_updates:
                merged_updates[chart_id] = []
            merged_updates[chart_id].append(update['data'])

        return merged_updates
```

## 3. 交互性设计

### 3.1 高级交互控件

```python
class AdvancedInteractivity:
    """高级交互功能"""

    @staticmethod
    def add_crossfilter_interaction(figs):
        """
        添加交叉筛选交互 - 多图表联动

        Args:
            figs: 图表对象列表

        Returns:
            list: 配置了交互的图表列表
        """
        for fig in figs:
            fig.update_layout(
                clickmode='event+select',
                dragmode='select'
            )

            # 添加选择事件回调
            fig.data[0].on_selection(
                lambda trace, points, selector:
                AdvancedInteractivity._handle_selection_event(trace, points, selector, figs)
            )

        return figs

    @staticmethod
    def _handle_selection_event(trace, points, selector, all_figs):
        """处理选择事件"""
        # 获取选择的数据范围
        if points.xs:
            x_range = [min(points.xs), max(points.xs)]

            # 更新所有关联图表的显示范围
            for fig in all_figs:
                fig.update_xaxes(range=x_range)

    @staticmethod
    def add_zoom_sync(figs):
        """添加缩放同步功能"""
        for fig in figs:
            fig.update_layout(
                xaxis=dict(
                    rangeslider=dict(visible=False),
                    autorange=False
                )
            )

        return figs

    @staticmethod
    def create_custom_controls():
        """创建自定义控制组件"""
        controls = {
            'time_range_slider': {
                'component': 'RangeSlider',
                'props': {
                    'min': 0,
                    'max': 30,
                    'value': [0, 30],
                    'step': 0.1,
                    'marks': {i: f'{i}s' for i in range(0, 31, 5)}
                }
            },
            'frequency_range_slider': {
                'component': 'RangeSlider',
                'props': {
                    'min': 0,
                    'max': 8000,
                    'value': [0, 8000],
                    'step': 10,
                    'marks': {i: f'{i}Hz' for i in range(0, 8001, 1000)}
                }
            },
            'filter_controls': {
                'component': 'FilterPanel',
                'props': {
                    'filter_types': ['low_pass', 'high_pass', 'band_pass'],
                    'cutoff_range': [1, 1000],
                    'order_range': [1, 10]
                }
            }
        }

        return controls
```

### 3.2 响应式布局

```python
class ResponsiveLayout:
    """响应式布局管理器"""

    @staticmethod
    def create_adaptive_layout(chart_config, screen_size='desktop'):
        """
        创建自适应布局

        Args:
            chart_config: 图表配置
            screen_size: 屏幕尺寸 ('mobile', 'tablet', 'desktop')

        Returns:
            dict: 自适应布局配置
        """
        layouts = {
            'mobile': {
                'rows': 4,
                'cols': 1,
                'height': 1200,
                'subplot_height': 250,
                'margin': {'l': 20, 'r': 20, 't': 40, 'b': 20}
            },
            'tablet': {
                'rows': 2,
                'cols': 2,
                'height': 800,
                'subplot_height': 350,
                'margin': {'l': 40, 'r': 40, 't': 60, 'b': 40}
            },
            'desktop': {
                'rows': 2,
                'cols': 2,
                'height': 800,
                'subplot_height': 350,
                'margin': {'l': 60, 'r': 60, 't': 80, 'b': 60}
            }
        }

        return layouts.get(screen_size, layouts['desktop'])

    @staticmethod
    def optimize_for_screen_size(fig, screen_size):
        """优化图表以适应屏幕尺寸"""
        optimizations = {
            'mobile': {
                'font_size': 10,
                'line_width': 1,
                'marker_size': 4,
                'legend_orientation': 'h',
                'title_font_size': 14
            },
            'tablet': {
                'font_size': 12,
                'line_width': 1.5,
                'marker_size': 6,
                'legend_orientation': 'h',
                'title_font_size': 16
            },
            'desktop': {
                'font_size': 14,
                'line_width': 2,
                'marker_size': 8,
                'legend_orientation': 'v',
                'title_font_size': 18
            }
        }

        config = optimizations.get(screen_size, optimizations['desktop'])

        fig.update_layout(
            font_size=config['font_size'],
            title_font_size=config['title_font_size'],
            legend_orientation=config['legend_orientation']
        )

        # 更新所有trace的样式
        fig.for_each_trace(
            lambda trace: trace.update(
                line_width=config['line_width'],
                marker_size=config['marker_size']
            )
        )

        return fig
```

这些可视化技术确保了系统能够高效、直观地展示齿轮磨损数据的多维特征，为研究人员提供强大的数据分析和探索工具。