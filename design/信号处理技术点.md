# 信号处理技术点详解

## 1. 时域信号处理

### 1.1 时域特征提取
齿轮磨损状态在时域信号中体现为统计特征和波形特征的变化。

```python
import numpy as np
from scipy import stats
from scipy.signal import hilbert, find_peaks

class TimeDomainFeatures:
    """时域特征提取器"""

    @staticmethod
    def basic_statistics(signal):
        """基础统计特征"""
        return {
            'mean': np.mean(signal),                    # 均值
            'std': np.std(signal),                      # 标准差
            'var': np.var(signal),                      # 方差
            'rms': np.sqrt(np.mean(signal**2)),         # 均方根值
            'peak': np.max(np.abs(signal)),             # 峰值
            'peak_to_peak': np.ptp(signal),             # 峰峰值
            'min_val': np.min(signal),                  # 最小值
            'max_val': np.max(signal)                   # 最大值
        }

    @staticmethod
    def shape_features(signal):
        """形状特征 - 反映信号分布特性"""
        return {
            'skewness': stats.skew(signal),             # 偏度 - 对称性
            'kurtosis': stats.kurtosis(signal),         # 峭度 - 尖峭程度
            'crest_factor': np.max(np.abs(signal)) / np.sqrt(np.mean(signal**2)),  # 波峰因子
            'clearance_factor': np.max(np.abs(signal)) / np.mean(np.sqrt(np.abs(signal)))**2,  # 裕度因子
            'impulse_factor': np.max(np.abs(signal)) / np.mean(np.abs(signal)),    # 脉冲因子
            'shape_factor': np.sqrt(np.mean(signal**2)) / np.mean(np.abs(signal))  # 形状因子
        }

    @staticmethod
    def energy_features(signal, sampling_rate):
        """能量特征"""
        # 信号能量
        energy = np.sum(signal**2)
        # 功率
        power = energy / len(signal)
        # 瞬时功率
        instantaneous_power = signal**2

        return {
            'total_energy': energy,
            'average_power': power,
            'peak_power': np.max(instantaneous_power),
            'power_std': np.std(instantaneous_power)
        }

    @staticmethod
    def amplitude_features(signal):
        """幅值域特征"""
        abs_signal = np.abs(signal)

        return {
            'mean_amplitude': np.mean(abs_signal),       # 平均幅值
            'median_amplitude': np.median(abs_signal),   # 中位幅值
            'amplitude_variance': np.var(abs_signal),    # 幅值方差
            'amplitude_range': np.max(abs_signal) - np.min(abs_signal)  # 幅值范围
        }
```

### 1.2 冲击特征检测
齿轮磨损常伴随冲击信号，冲击检测对故障诊断至关重要。

```python
class ImpactDetector:
    """冲击信号检测器"""

    def __init__(self, threshold_multiplier=3.0):
        self.threshold_multiplier = threshold_multiplier

    def detect_impacts(self, signal, sampling_rate):
        """
        检测信号中的冲击事件

        Args:
            signal: 输入信号
            sampling_rate: 采样频率

        Returns:
            dict: 冲击特征信息
        """
        # 计算包络
        envelope = self._compute_envelope(signal)

        # 动态阈值
        threshold = np.mean(envelope) + self.threshold_multiplier * np.std(envelope)

        # 寻找峰值
        peaks, properties = find_peaks(
            envelope,
            height=threshold,
            distance=int(sampling_rate * 0.001)  # 最小间距1ms
        )

        # 计算冲击特征
        impact_features = self._analyze_impacts(signal, peaks, envelope, sampling_rate)

        return impact_features

    def _compute_envelope(self, signal):
        """计算信号包络"""
        # 使用Hilbert变换计算解析信号
        analytic_signal = hilbert(signal)
        return np.abs(analytic_signal)

    def _analyze_impacts(self, signal, peaks, envelope, sampling_rate):
        """分析冲击特征"""
        if len(peaks) == 0:
            return {
                'impact_count': 0,
                'impact_rate': 0,
                'max_impact_amplitude': 0,
                'mean_impact_amplitude': 0,
                'impact_energy_ratio': 0
            }

        # 冲击幅值
        impact_amplitudes = envelope[peaks]

        # 冲击间隔
        if len(peaks) > 1:
            impact_intervals = np.diff(peaks) / sampling_rate
            mean_interval = np.mean(impact_intervals)
            impact_rate = 1.0 / mean_interval if mean_interval > 0 else 0
        else:
            impact_rate = 0

        # 冲击能量占比
        total_energy = np.sum(signal**2)
        impact_energy = np.sum(impact_amplitudes**2)
        energy_ratio = impact_energy / total_energy if total_energy > 0 else 0

        return {
            'impact_count': len(peaks),
            'impact_rate': impact_rate,
            'max_impact_amplitude': np.max(impact_amplitudes),
            'mean_impact_amplitude': np.mean(impact_amplitudes),
            'impact_energy_ratio': energy_ratio,
            'impact_positions': peaks / sampling_rate  # 时间位置
        }
```

## 2. 频域信号处理

### 2.1 频谱分析技术

```python
from scipy.signal import welch, periodogram, hann
from scipy.fft import fft, fftfreq

class FrequencyAnalyzer:
    """频域分析器"""

    def __init__(self, sampling_rate):
        self.sampling_rate = sampling_rate

    def compute_fft_spectrum(self, signal, window='hann'):
        """
        计算FFT频谱

        Args:
            signal: 时域信号
            window: 窗函数类型

        Returns:
            tuple: (频率, 幅值谱, 相位谱)
        """
        # 应用窗函数
        if window == 'hann':
            windowed_signal = signal * hann(len(signal))
        else:
            windowed_signal = signal

        # 计算FFT
        fft_result = fft(windowed_signal)
        freqs = fftfreq(len(signal), 1/self.sampling_rate)

        # 只取正频率部分
        positive_freqs = freqs[:len(freqs)//2]
        amplitude_spectrum = np.abs(fft_result[:len(freqs)//2])
        phase_spectrum = np.angle(fft_result[:len(freqs)//2])

        return positive_freqs, amplitude_spectrum, phase_spectrum

    def compute_power_spectral_density(self, signal, method='welch', nperseg=1024):
        """
        计算功率谱密度

        Args:
            signal: 输入信号
            method: 计算方法 ('welch', 'periodogram')
            nperseg: 每段长度（对welch方法）

        Returns:
            tuple: (频率, 功率谱密度)
        """
        if method == 'welch':
            freqs, psd = welch(
                signal,
                fs=self.sampling_rate,
                nperseg=nperseg,
                window='hann',
                overlap=nperseg//2
            )
        elif method == 'periodogram':
            freqs, psd = periodogram(
                signal,
                fs=self.sampling_rate,
                window='hann'
            )

        return freqs, psd

    def extract_frequency_features(self, freqs, spectrum):
        """
        提取频域特征

        Args:
            freqs: 频率数组
            spectrum: 频谱幅值

        Returns:
            dict: 频域特征
        """
        # 频率加权中心频率
        spectral_centroid = np.sum(freqs * spectrum) / np.sum(spectrum)

        # 频带能量分布
        total_energy = np.sum(spectrum**2)

        # 定义频带
        low_freq_idx = freqs <= 1000
        mid_freq_idx = (freqs > 1000) & (freqs <= 5000)
        high_freq_idx = freqs > 5000

        low_energy_ratio = np.sum(spectrum[low_freq_idx]**2) / total_energy
        mid_energy_ratio = np.sum(spectrum[mid_freq_idx]**2) / total_energy
        high_energy_ratio = np.sum(spectrum[high_freq_idx]**2) / total_energy

        # 主要频率成分
        peak_indices = find_peaks(spectrum, height=np.max(spectrum)*0.1)[0]
        dominant_freqs = freqs[peak_indices]

        return {
            'spectral_centroid': spectral_centroid,
            'low_freq_energy_ratio': low_freq_ratio,
            'mid_freq_energy_ratio': mid_energy_ratio,
            'high_freq_energy_ratio': high_energy_ratio,
            'dominant_frequencies': dominant_freqs,
            'spectral_peak_count': len(peak_indices),
            'frequency_variance': np.sum((freqs - spectral_centroid)**2 * spectrum) / np.sum(spectrum)
        }
```

### 2.2 齿轮特征频率分析

```python
class GearFrequencyAnalyzer:
    """齿轮特征频率分析器"""

    def __init__(self, gear_parameters):
        """
        Args:
            gear_parameters: dict containing:
                - drive_teeth: 主动轮齿数
                - driven_teeth: 从动轮齿数
                - shaft_speed: 轴转速 (rpm)
        """
        self.drive_teeth = gear_parameters.get('drive_teeth', 20)
        self.driven_teeth = gear_parameters.get('driven_teeth', 60)
        self.shaft_speed_rpm = gear_parameters.get('shaft_speed', 1000)

        # 转换为Hz
        self.shaft_freq_hz = self.shaft_speed_rpm / 60

        # 计算特征频率
        self.gear_mesh_freq = self.shaft_freq_hz * self.drive_teeth
        self.drive_gear_freq = self.shaft_freq_hz
        self.driven_gear_freq = self.shaft_freq_hz * self.drive_teeth / self.driven_teeth

    def analyze_gear_frequencies(self, freqs, spectrum):
        """
        分析齿轮特征频率成分

        Returns:
            dict: 齿轮频率分析结果
        """
        # 定义频率容差
        tolerance = 5  # Hz

        # 寻找特征频率及其谐波
        mesh_harmonics = self._find_harmonics(
            freqs, spectrum, self.gear_mesh_freq, tolerance, max_order=10
        )

        drive_harmonics = self._find_harmonics(
            freqs, spectrum, self.drive_gear_freq, tolerance, max_order=5
        )

        driven_harmonics = self._find_harmonics(
            freqs, spectrum, self.driven_gear_freq, tolerance, max_order=5
        )

        # 分析边频带（调制效应）
        sidebands = self._analyze_sidebands(
            freqs, spectrum, self.gear_mesh_freq,
            [self.drive_gear_freq, self.driven_gear_freq], tolerance
        )

        return {
            'gear_mesh_frequency': self.gear_mesh_freq,
            'mesh_harmonics': mesh_harmonics,
            'drive_gear_harmonics': drive_harmonics,
            'driven_gear_harmonics': driven_harmonics,
            'sidebands': sidebands,
            'mesh_energy_ratio': self._calculate_energy_ratio(spectrum, mesh_harmonics)
        }

    def _find_harmonics(self, freqs, spectrum, fundamental_freq, tolerance, max_order):
        """寻找谐波成分"""
        harmonics = []

        for order in range(1, max_order + 1):
            target_freq = fundamental_freq * order

            # 寻找目标频率附近的峰值
            freq_mask = np.abs(freqs - target_freq) <= tolerance
            if np.any(freq_mask):
                local_spectrum = spectrum[freq_mask]
                local_freqs = freqs[freq_mask]

                peak_idx = np.argmax(local_spectrum)
                harmonics.append({
                    'order': order,
                    'frequency': local_freqs[peak_idx],
                    'amplitude': local_spectrum[peak_idx],
                    'theoretical_freq': target_freq
                })

        return harmonics

    def _analyze_sidebands(self, freqs, spectrum, carrier_freq, modulation_freqs, tolerance):
        """分析边频带"""
        sidebands = []

        for mod_freq in modulation_freqs:
            # 上边频和下边频
            upper_sideband = carrier_freq + mod_freq
            lower_sideband = carrier_freq - mod_freq

            # 检查上边频
            upper_mask = np.abs(freqs - upper_sideband) <= tolerance
            if np.any(upper_mask):
                upper_amplitude = np.max(spectrum[upper_mask])
                sidebands.append({
                    'type': 'upper',
                    'frequency': upper_sideband,
                    'amplitude': upper_amplitude,
                    'modulation_freq': mod_freq
                })

            # 检查下边频
            if lower_sideband > 0:
                lower_mask = np.abs(freqs - lower_sideband) <= tolerance
                if np.any(lower_mask):
                    lower_amplitude = np.max(spectrum[lower_mask])
                    sidebands.append({
                        'type': 'lower',
                        'frequency': lower_sideband,
                        'amplitude': lower_amplitude,
                        'modulation_freq': mod_freq
                    })

        return sidebands

    def _calculate_energy_ratio(self, spectrum, harmonics):
        """计算谐波能量占比"""
        total_energy = np.sum(spectrum**2)
        harmonic_energy = sum([h['amplitude']**2 for h in harmonics])

        return harmonic_energy / total_energy if total_energy > 0 else 0
```

## 3. 时频分析

### 3.1 小波变换分析

```python
import pywt
from scipy.signal import spectrogram

class TimeFrequencyAnalyzer:
    """时频分析器"""

    def __init__(self, sampling_rate):
        self.sampling_rate = sampling_rate

    def continuous_wavelet_transform(self, signal, wavelet='cmor', scales=None):
        """
        连续小波变换

        Args:
            signal: 输入信号
            wavelet: 小波类型
            scales: 尺度序列

        Returns:
            tuple: (系数矩阵, 频率数组, 时间数组)
        """
        if scales is None:
            scales = np.arange(1, 128)

        # 执行连续小波变换
        coefficients, frequencies = pywt.cwt(signal, scales, wavelet)

        # 时间轴
        time = np.arange(len(signal)) / self.sampling_rate

        return coefficients, frequencies, time

    def short_time_fourier_transform(self, signal, window='hann', nperseg=256, noverlap=None):
        """
        短时傅里叶变换

        Returns:
            tuple: (频率, 时间, 时频谱)
        """
        if noverlap is None:
            noverlap = nperseg // 2

        freqs, times, Zxx = spectrogram(
            signal,
            fs=self.sampling_rate,
            window=window,
            nperseg=nperseg,
            noverlap=noverlap
        )

        return freqs, times, np.abs(Zxx)

    def extract_timefreq_features(self, coefficients, frequencies, times):
        """
        提取时频特征

        Args:
            coefficients: 小波系数或STFT系数
            frequencies: 频率数组
            times: 时间数组

        Returns:
            dict: 时频特征
        """
        energy_matrix = np.abs(coefficients)**2

        # 瞬时频率
        instantaneous_freq = self._compute_instantaneous_frequency(
            coefficients, frequencies
        )

        # 频率方差随时间变化
        freq_variance_time = []
        for t_idx in range(len(times)):
            time_slice = energy_matrix[:, t_idx]
            freq_var = np.sum((frequencies.reshape(-1, 1) - np.average(frequencies, weights=time_slice))**2 * time_slice.reshape(-1, 1))
            freq_variance_time.append(freq_var)

        # 能量分布
        total_energy = np.sum(energy_matrix)

        # 时间-频率能量重心
        time_centroid = np.sum(np.sum(energy_matrix, axis=0) * times) / total_energy
        freq_centroid = np.sum(np.sum(energy_matrix, axis=1) * frequencies) / total_energy

        return {
            'instantaneous_frequency': instantaneous_freq,
            'frequency_variance_vs_time': freq_variance_time,
            'time_centroid': time_centroid,
            'frequency_centroid': freq_centroid,
            'energy_concentration': np.max(energy_matrix) / total_energy
        }

    def _compute_instantaneous_frequency(self, coefficients, frequencies):
        """计算瞬时频率"""
        # 找到每个时刻的主导频率
        instantaneous_freq = []

        for t_idx in range(coefficients.shape[1]):
            energy_at_t = np.abs(coefficients[:, t_idx])**2
            dominant_freq_idx = np.argmax(energy_at_t)
            instantaneous_freq.append(frequencies[dominant_freq_idx])

        return np.array(instantaneous_freq)
```

## 4. 信号滤波与降噪

### 4.1 数字滤波器设计

```python
from scipy.signal import butter, filtfilt, iirfilter, hilbert

class AdvancedFilter:
    """高级数字滤波器"""

    def __init__(self, sampling_rate):
        self.fs = sampling_rate
        self.nyquist = sampling_rate / 2

    def bandpass_filter(self, signal, low_freq, high_freq, order=4, filter_type='butter'):
        """
        带通滤波器

        Args:
            signal: 输入信号
            low_freq: 下截止频率
            high_freq: 上截止频率
            order: 滤波器阶数
            filter_type: 滤波器类型
        """
        low = low_freq / self.nyquist
        high = high_freq / self.nyquist

        if filter_type == 'butter':
            b, a = butter(order, [low, high], btype='band')
        else:
            b, a = iirfilter(order, [low, high], btype='band', ftype=filter_type)

        # 零相位滤波
        filtered_signal = filtfilt(b, a, signal)
        return filtered_signal

    def adaptive_filter(self, signal, reference_freq, adaptation_rate=0.01):
        """
        自适应滤波器 - 用于消除特定频率的干扰

        Args:
            signal: 输入信号
            reference_freq: 参考频率（要消除的频率）
            adaptation_rate: 适应速率
        """
        # 生成参考信号
        time = np.arange(len(signal)) / self.fs
        reference = np.sin(2 * np.pi * reference_freq * time)

        # LMS自适应算法
        filtered_signal = np.copy(signal)
        weight = 0.0

        for i in range(1, len(signal)):
            # 预测干扰
            interference_estimate = weight * reference[i]

            # 误差信号
            error = signal[i] - interference_estimate

            # 更新权重
            weight += adaptation_rate * error * reference[i]

            # 输出滤波信号
            filtered_signal[i] = error

        return filtered_signal

    def envelope_filter(self, signal, envelope_freq_cutoff=100):
        """
        包络滤波 - 用于冲击信号处理

        Args:
            signal: 输入信号
            envelope_freq_cutoff: 包络信号截止频率
        """
        # 计算解析信号
        analytic_signal = hilbert(signal)
        envelope = np.abs(analytic_signal)

        # 对包络信号进行低通滤波
        cutoff_normalized = envelope_freq_cutoff / self.nyquist
        b, a = butter(4, cutoff_normalized, btype='low')
        filtered_envelope = filtfilt(b, a, envelope)

        return filtered_envelope
```

### 4.2 噪声抑制技术

```python
class NoiseReducer:
    """噪声抑制器"""

    @staticmethod
    def spectral_subtraction(signal, noise_spectrum, alpha=2.0, beta=0.1):
        """
        谱减法降噪

        Args:
            signal: 含噪信号
            noise_spectrum: 噪声功率谱估计
            alpha: 过减因子
            beta: 谱底限因子
        """
        # 计算信号频谱
        signal_fft = fft(signal)
        signal_magnitude = np.abs(signal_fft)
        signal_phase = np.angle(signal_fft)

        # 谱减法
        enhanced_magnitude = signal_magnitude - alpha * np.sqrt(noise_spectrum)

        # 应用谱底限
        enhanced_magnitude = np.maximum(
            enhanced_magnitude,
            beta * signal_magnitude
        )

        # 重构信号
        enhanced_fft = enhanced_magnitude * np.exp(1j * signal_phase)
        enhanced_signal = np.real(np.fft.ifft(enhanced_fft))

        return enhanced_signal

    @staticmethod
    def wiener_filter(signal, noise_variance, signal_variance=None):
        """
        维纳滤波器

        Args:
            signal: 输入信号
            noise_variance: 噪声方差
            signal_variance: 信号方差（如果为None则从数据估计）
        """
        if signal_variance is None:
            signal_variance = np.var(signal)

        # 维纳滤波器系数
        wiener_gain = signal_variance / (signal_variance + noise_variance)

        # 应用滤波器
        filtered_signal = wiener_gain * signal

        return filtered_signal

    @staticmethod
    def wavelet_denoising(signal, wavelet='db4', threshold_mode='soft'):
        """
        小波去噪

        Args:
            signal: 输入信号
            wavelet: 小波类型
            threshold_mode: 阈值模式 ('soft' 或 'hard')
        """
        # 小波分解
        coeffs = pywt.wavedec(signal, wavelet, level=6)

        # 计算阈值（使用软阈值）
        threshold = np.sqrt(2 * np.log(len(signal))) * np.std(coeffs[-1])

        # 应用阈值
        coeffs_thresh = list(coeffs)
        coeffs_thresh[1:] = [
            pywt.threshold(c, threshold, mode=threshold_mode)
            for c in coeffs[1:]
        ]

        # 重构信号
        denoised_signal = pywt.waverec(coeffs_thresh, wavelet)

        return denoised_signal
```

这些信号处理技术为齿轮磨损状态的准确识别提供了强大的分析工具，能够从多个角度提取和分析信号特征。